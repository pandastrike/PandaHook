#!/bin/bash
#===============================================================================
# Panda Hook
#===============================================================================
# Githooks are powerful tools.  Whatever you can script can be performed for you
# automatically from nothing but a git command.  Panda Hook helps you manage
# this magic.

# This bash script is the top level of Panda Hook.  It has a modular design so
# that it stays flexible for your needs.  Ultimately, Panda Hook helps you
# manage githook scripts and deploy them to your hook-server.  A hook-server
# accepts pushes from your local git repo and takes action with server-side githooks.
#===============================================================================

#echo $pandahook_target

#===============================================================================
# Function Definitions
#===============================================================================
help_blurb ()
{
  # This function simply echoes a brief guide to Panda Hook.

  echo "Usage: pandahook [OPTIONS] COMMAND [arg...]"
  echo "--------------------------------------------"
  echo "Follow any command with \"help\" for more information."
  echo ""
  echo "A tool to manage githook scripts and deploy them to your hook-server."
  echo ""
  echo "Commands:"
  echo "   build     Generates a githook script"
  echo "   create    Clones a remote, bare repo on the hook-server"
  echo "   destroy   Deletes a remote repo from the hook-server"
  echo "   init      Setup pandahook with details about the hook-server"
  echo "   push      Adds the specified githook script to remote repo on the hook-server"
  echo "   rm        Deletes the specifed githook script from the remote repo on the hook-server"
  echo "   status    Gives details about Panda Hook configuration."
  echo ""
}

init_command ()
{
  # This command accepts and exports details about the hook-server as environment
  # variables.  These will be used by other Panda Hook commands to accomplish their
  # tasks on the (usually remote) hook-server.

  # Check the number of arguments.  If there is nothing after "init", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook init ADDRESS"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "Init accepts the details neccessary to connect to the (usually remote) hook-server."
    echo "These details are stored as environment variables so that other Panda Hook commands"
    echo "may use them to accomplish tasks."
    echo ""
    echo "ADDRESS format: user@server-address"
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Store the hook-server's address.
  export pandahook_target=$2
  echo ""
  echo "The address \"$2\" has been stored.  Panda Hook is now ready to interface with the hook-server."
  echo ""
}

status_command ()
{
  # This command simply echoes Panda Hook configuration data.

  # Deliver the manual blurb if there is a "help" command.
  if [[ ("$2" == "help") ]]; then
    echo "Usage: pandahook status"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "Status provides configuraiton details about Panda Hook.  These details"
    echo "are pulled from environmental variables in the \"pandahook\" namespace."
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Display Panda Hook's configuration.
  echo "=================="
  echo "  Configuration"
  echo "=================="

  # Stored address of the hook-server.  Check if the variable is unset.
  if [ -z "$pandahook_target" ];
    then
      echo "Hook-Server Address: This is currently unset."
    else
      echo "Hook-Server Address: $pandahook_target"
  fi

  # Known repos, listed by name with accompanying source.  Check if the variable is unset.
  if [ -z "$pandahook_repo_name" ];
    then
      echo "Repo: None currently exist."
    else
      echo "Repo: $pandahook_repo_name    $pandahook_repo_source"
  fi

  echo ""
}

create_command ()
{
  # This command clones a bare repo on the hook-server.  Panda Hook knows the
  # location of the hook-server, so here we take the location of original
  # repo and make a bare clone, a repo that lacks a working tree but accepts
  # pushes into its commit history.

  # Check the number of arguments.  If there is nothing after "create", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook create NAME SOURCE_ADDRESS"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "Create accepts the details neccessary to create a bare repo on the hook-server."
    echo "These details are stored as environment variables so that other Panda Hook commands"
    echo "may use them to accomplish tasks."
    echo ""
    echo "Create needs a source git repo to produce a clone.  You provide an arbitrary name"
    echo "to this source so you can easily reference the repo in other commands."
    echo ""
    echo "NAME           format: string"
    echo "SOURCE_ADDRESS format: user@server-address  (Access via SSH, not HTTPS)"
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Create the bare clone.  Check to make sure a directory with that name doesn't already exist.
  ssh $pandahook_target /usr/bin/bash << EOF
      if [ -d "$2" ]; then
          echo ""
          echo "WARNGING: A directory named $2 has been detected.  Overwriting."
          echo ""
          rm -rf "$2"
      fi

      /usr/bin/git clone --bare $3 $2
EOF

  # Store the name and source address.
  export pandahook_repo_source=$3
  export pandahook_repo_name=$2
  echo ""
  echo "The bare repo \"$2\" has been successfully cloned from \"$3\"."
  echo "\"$2\" is now ready to accept githooks."
  echo ""


}

destroy_command ()
{
  # This command removes the specified bare repo from the hook-server.  Panda Hook knows the
  # location of the hook-server, so all we need is a name to perform the deletion.

  # Check the number of arguments.  If there is nothing after "destroy", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook destroy NAME"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "Destroy accepts the name of the bare repo to delete from the hook-server."
    echo "Use with caution, the remote repo and all githooks will permanently deleted."

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Delete the remote repo.
  ssh $pandahook_target "rm -rf $2"

  # Store the name and source address.
  unset pandahook_repo_source
  unset pandahook_repo_name
  echo ""
  echo "The bare repo \"$2\" has been successfully deleted from the hook-server."
  echo ""


}


push_command ()
{
  # This command places a githook script onto the hook-server.  Panda Hook knows the
  # location of the hook-server, so here we take the repo name and place the script
  # into its "hooks" directory.

  # Check the number of arguments.  If there is nothing after "push", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook push REPO_NAME GITHOOK_FILENAME"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "Push places a githook script into a bare repo on the hook-server."
    echo "These are loaded as executable scripts in the \"hooks\" directory."
    echo ""
    echo "REPO_NAME         format: string"
    echo "GITHOOK_FILENAME  format: filename (must be named one of the githook types)"
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Place the githook into the remote repo and make it executable.
  scp $3 "$pandahook_target:$2/hooks"
  ssh $pandahook_target "cd $2/hooks; chmod +x $3"

  echo ""
  echo "The githook \"$3\" has been successfully pushed to \"$2\" and is online."
  echo ""


}

rm_command ()
{
  # This command removes a githook script from the hook-server.  Panda Hook knows the
  # location of the hook-server, so here we take the repo name and remove the named script
  # from its "hooks" directory.

  # Check the number of arguments.  If there is nothing after "rm", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook rm REPO_NAME GITHOOK_FILENAME"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "rm deletes a githook script from the bare repo on the hook-server."
    echo "These are executable scripts located in the \"hooks\" directory."
    echo ""
    echo "REPO_NAME         format: string"
    echo "GITHOOK_FILENAME  format: filename (must be named one of the githook types)"
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Remove the githook from the remote repo.
  ssh $pandahook_target "cd $2/hooks; rm -f $3"

  echo ""
  echo "The githook \"$3\" has been successfully removed from \"$2\"."
  echo ""
}


build_command ()
{
  # This function automates the process of writing githook scripts.

  # Check the number of arguments.  If there is nothing after "build", deliver a manual blurb.
  # Also deliver this blurb is the command is "help"
  if [[ ("$#" == 1) || ("$2" == "help") ]]; then
    echo "Usage: pandahook build MODULE [arg...]"
    echo "--------------------------------------------"
    echo "Follow any command with \"help\" for more information."
    echo ""
    echo "BUILD automates the process of writing githook scripts. Compared to the other"
    echo "commands, build has the most options.  That's why it is further subdivided into"
    echo "\"modules\" that give us flexibility."
    echo ""
    echo "For example:  Say we need a githook that restarts a service on a CoreOS cluster, so our"
    echo "githook makes use of fleetctl.  But that only applies to projects that use CoreOS."
    echo "Another technology stack will need a completely different set of commands to do the same thing."
    echo ""
    echo "The BUILD command abstracts the steps needed to (in this example) restart a deployment,"
    echo "and bundles unique dependencies (like fleetctl) into \"modules\" that can be specified in its options."
    echo ""
    echo "MODULE        format: string"
    echo ""

    exit
  fi


  #-----------------
  # Command Parsing
  #-----------------
  # Create the bare clone.  Check to make sure a directory with that name doesn't already exist.
  ssh $pandahook_target /usr/bin/bash << EOF
      if [ -d "$2" ]; then
          echo ""
          echo "WARNGING: A directory named $2 has been detected.  Overwriting."
          echo ""
          rm -rf "$2"
      fi

      /usr/bin/git clone --bare $3 $2
EOF

  # Store the name and source address.
  export pandahook_repo_source=$3
  export pandahook_repo_name=$2
  echo ""
  echo "The bare repo \"$2\" has been successfully cloned from \"$3\"."
  echo "\"$2\" is now ready to accept githooks."
  echo ""


}

#===============================================================================
# Command Parsing
#===============================================================================

# First, check the number of arguments.  Deliver a manual blurb when none are present.
# Also deliver this blurb is the command is "help"
if [[ ("$#" == 0) || ("$1" == "help") ]]; then
  help_blurb
  exit
fi

case "$1" in
  build)
    build_command "$@"
    ;;
  create)
    create_command "$@"
    ;;
  destroy)
    destroy_command "$@"
    ;;
  init)
    init_command "$@"
    ;;
  push)
    push_command "$@"
    ;;
  rm)
    rm_command "$@"
    ;;
  status)
    status_command "$@"
    ;;
  *)  # When the command cannot be identified, echo the help guide.
    echo ""
    echo "Error: Command not found: $1"
    echo ""
    help_blurb
    exit
    ;;
esac
