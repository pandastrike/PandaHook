#=================================================================================
# CoreOS Restart - Generated by PandaHook https://github.com/pandastrike/panda-hook
#=================================================================================
# This Bash script controls the actions of a hook-server. While triggered by a git
# command, this server can taking any additional action possible on a Linux machine.

# Algorithm:
# (1) Perform a clone of the "bare" repo we just pushed to, creating a regular repo.
# (2) Use the *.service files in the regular repo to re-deploy CoreOS services.


# Core Libraries
fs = require "fs"
{resolve, join} = require "path"

Configurator = require "panda-config"           # -----------------
{simple_render} = require "./templatize"
{chdir, read, write, read_block, lines, times, readdir, shell, stat, sleep} = require "fairmont"

# Third Party Libraries
{call} = require "when/generator"
{promise} = require "when"
async = (require "when/generator").lift         # -----------------
{exec} = require "shelljs"                      # command-line access
{render} = require "mustache"

repo_name = "{{{repo_name}}}"

repo_path = "#{process.env.HOME}/repos/#{repo_name}"
launch_path = repo_path + "/launch/"


# fills in template with values, writes to file
render_template_wrapper = async ({repo_name, component_name, template_filename, output_filename, branch_name}) ->
  template_path =  repo_path + "/launch/" + "#{component_name}/#{template_filename}"
  template = yield read template_path
  configuration_path = join repo_path, "huxley.yaml"
  configuration = (require "js-yaml").safeLoad (yield read configuration_path)
  configuration.branch_name = "master"
  
  rendered_string = render template, configuration
  
  yield write (resolve repo_path + "/launch/#{component_name}/#{output_filename}"), rendered_string
  

# ShellJS's "exec" command can run non-blocking, so we wrap it here with a promise to use with
# generators.  Future iterations will probably include error handling refinements here.
execute = (command) ->
  promise (resolve, reject) ->
    exec command, (code, output) ->
      resolve output



print_banner = (text) ->
  console.log "\n"
  console.log "==============================================================="
  console.log "#{text}"
  console.log "==============================================================="


print_banner "Push Detected. Activating Githook."

get_dirs = async (path) ->
  file for file in (yield readdir path) when (yield stat (join path, file)).isDirectory()


# First, determine the branch being pushed and checkout that one.  That information is available
# from the standard input.
call ->
  # Cloning the (freshly updated) bare repo creates a regular one with files we can use.
  # Note that our starting directory is the repo's root, not the path of the githook script.
  print_banner "Cloning Bare Repo"

  #[ignore..., branch_name] = times (read_block lines process.stdin), 3
  #branch_name = yield branch_name
  branch_name = "master"

  # Next, wipe away any old versions of the regular repo and clone from the updated bare repo.
  yield shell "rm -rf #{repo_path}"
  yield shell "/usr/bin/git clone -b #{branch_name} -- #{process.env.HOME}/repos/#{repo_name}.git #{repo_path}"


  # Determine which services should be restarted by searching the regular repo's "launch"
  # directory.  Every subdirectory there represents something that needs a restart.
  print_banner "Stopping Service(s)"

  services = yield get_dirs repo_path + "/launch"

  for service in services
    yield execute "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} /usr/bin/fleetctl destroy #{service}.service;"


  # It sometimes takes the CoreOS cluster a moment to register your command.
  # If we wait a few seconds, the service will properly begin the termination sequence
  # before registering the following "start" command.
  yield sleep 5000

  # Finally, bring the service(s) back online.
  # Delete the current launch directory if it stands in our way.
  print_banner "Restarting Service(s)"

  for service in services
    yield render_template_wrapper
      component_name: service
      template_filename: "#{service}.service.template"
      output_filename: "#{service}.service"
      branch_name: branch_name
    yield render_template_wrapper
      component_name: service
      template_filename: "Dockerfile.template"
      output_filename: "Dockerfile"
      branch_name: branch_name


  console.log "TAKE 5"
  yield sleep 5000
  try
    #{stdout, stderr} = yield shell "(cd #{repo_path} && git status)"
    {stdout, stderr} = yield shell "(git -C #{repo_path} add .)"
    # yield shell "git commit -m 'rendered templates'"
  catch error
    console.log error
  console.log {stdout, stderr}

#  yield execute "cd /root/repos/#{repo_name} && GIT_WORK_TREE=/root/repos/#{repo_name} && echo $GIT_WORK_TREE >> git-dir && git add . && git commit -m 'rendered templates'"

  for service in services
    yield shell "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} sudo rm -rf prelaunch/#{service}"
    yield shell "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P {{{cluster_port}}} -r #{repo_path}/launch/#{service} {{{cluster_address}}}:/home/core/prelaunch/"
    yield shell "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} /usr/bin/fleetctl start prelaunch/#{service}/#{service}.service"

