#=================================================================================
# CoreOS Restart - Generated by PandaHook https://github.com/pandastrike/panda-hook
#=================================================================================
# This Bash script controls the actions of a hook-server. While triggered by a git
# command, this server can taking any additional action possible on a Linux machine.

# Algorithm:
# (1) Perform a clone of the "bare" repo we just pushed to, creating a regular repo.
# (2) Use the *.service files in the regular repo to re-deploy CoreOS services.


# Core Libraries
fs = require "fs"
{resolve, join} = require "path"

Configurator = require "panda-config"           # -----------------
{simple_render} = require "./templatize"
{read_block, lines, times, readdir, shell, stat, sleep} = require "fairmont"

# Third Party Libraries
{call} = require "when/generator"
{promise} = require "when"
async = (require "when/generator").lift         # -----------------
{exec} = require "shelljs"                      # command-line access




repo_path = "#{process.env.HOME}/repos/donuts"
launch_path = repo_path + "/launch/"


# fills in template with values, writes to file
render_template_wrapper = async ({repo_name, component_name, template_filename, output_filename}) ->
  template_path =  repo_path + "/launch/" + "#{component_name}/#{template_filename}"

  # read in the default component.yaml (to make accessable as CSON)
  configurator = Configurator.make
    paths: [ repo_path ]
    extension: ".yaml"
  configuration = configurator.make name: "huxley"
  yield configuration.load()

  rendered_string = yield simple_render configuration.data, template_path
  fs.writeFileSync (repo_path + "/launch/#{component_name}/#{output_filename}"), rendered_string
  yield configuration.save()


# ShellJS's "exec" command can run non-blocking, so we wrap it here with a promise to use with
# generators.  Future iterations will probably include error handling refinements here.
execute = (command) ->
  promise (resolve, reject) ->
    exec command, (code, output) ->
      resolve output



print_banner = (text) ->
  console.log "\n"
  console.log "==============================================================="
  console.log "#{text}"
  console.log "==============================================================="


print_banner "Push Detected. Activating Githook."

get_dirs = async (path) ->
  file for file in (yield readdir path) when (yield stat (join path, file)).isDirectory()


# First, determine the branch being pushed and checkout that one.  That information is available
# from the standard input.
call ->
  # Cloning the (freshly updated) bare repo creates a regular one with files we can use.
  # Note that our starting directory is the repo's root, not the path of the githook script.
  print_banner "Cloning Bare Repo"
  [ignore..., branch_name] = times (read_block lines process.stdin), 3
  yield branch_name

  # Next, wipe away any old versions of the regular repo and clone from the updated bare repo.
  yield shell "rm -rf #{repo_path}"
  yield shell "/usr/bin/git clone -b #{branch_name} #{process.env.HOME}/repos/donuts.git #{repo_path}"


  # Determine which services should be restarted by searching the regular repo's "launch"
  # directory.  Every subdirectory there represents something that needs a restart.
  print_banner "Stopping Service(s)"

  services = yield get_dirs repo_path + "/launch"

  for service in services
    yield execute "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} /usr/bin/fleetctl destroy #{service}.service;"


  # It sometimes takes the CoreOS cluster a moment to register your command.
  # If we wait a few seconds, the service will properly begin the termination sequence
  # before registering the following "start" command.
  yield sleep 5000

  # Finally, bring the service(s) back online.
  # Delete the current launch directory if it stands in our way.
  print_banner "Restarting Service(s)"

  for service in services
    yield render_template_wrapper
      component_name: service
      template_filename: "#{service}.service.template"
      output_filename: "#{service}.service"
    yield render_template_wrapper
      component_name: service
      template_filename: "Dockerfile.template"
      output_filename: "Dockerfile"

    yield shell "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} sudo rm -rf launch/#{service}"
    yield shell "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P {{{cluster_port}}} -r #{repo_path}/launch/#{service} {{{cluster_address}}}:/home/core/launch/"
    yield shell "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p {{{cluster_port}}} {{{cluster_address}}} /usr/bin/fleetctl start launch/#{service}/#{service}.service"

